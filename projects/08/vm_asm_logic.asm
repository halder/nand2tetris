// Logic for Hack assembly implementations of VM commands

// ---------------------------------------------------------------------------------------------------------------------------------
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//// --- PROGRAM FLOW --- //////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// ---------------------------------------------------------------------------------------------------------------------------------

//// --- label ---------------------------------------------------------------------------------------------------------------- ////
($$functionName$label$$)

//// --- goto ----------------------------------------------------------------------------------------------------------------- ////
@$$GOTO_LOCATION$$
0;JMP

//// --- if ------------------------------------------------------------------------------------------------------------------- ////
@SP
AM=M-1
D=M
@$$IF_GOTO_LOCATION$$
D;JNE

// ---------------------------------------------------------------------------------------------------------------------------------
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//// --- FUNCTION CALLING --- //////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// ---------------------------------------------------------------------------------------------------------------------------------

//// --- call ----------------------------------------------------------------------------------------------------------------- ////
    @$$functionName.ret.n$$
    D=A
    @SP
    M=M+1
    A=M-1
    M=D                     // push return-address onto stack
    @LCL
    D=M
    @SP
    M=M+1
    A=M-1
    M=D                     // push LCL onto stack
    @ARG
    D=M
    @SP
    M=M+1
    A=M-1
    M=D                     // push ARG onto stack
    @THIS
    D=M
    @SP
    M=M+1
    A=M-1
    M=D                     // push THIS onto stack
    @THAT
    D=M
    @SP
    M=M+1
    A=M-1
    M=D                     // push THAT onto stack
    @$$arg2$$               // n
    D=A
    @5
    D=D+A                   // n+5
    @SP
    D=M-D
    @ARG
    M=D
    @SP
    D=M
    @LCL
    M=D
    @$$functionName$$
    0;JMP
($$functioName.ret.n$$)     // return-address

//// --- function ------------------------------------------------------------------------------------------------------------- ////
($$functionName$$)
    @$$arg2$$               // k
    D=A
    @$$ARGisZERO$$
    D;JEQ
($$InitLoop$$)
    @SP
    M=M+1
    A=M-1
    M=0
    @$$InitLoop$$
    D=D-1;JGT
($$ARGisZERO$$)

//// --- return --------------------------------------------------------------------------------------------------------------- ////
@LCL
D=M
@R13        // FRAME
M=D
@5
A=D-A       // FRAME-5
D=M         // return address
@R14        // RET
M=D         // RET
@SP
A=M-1
D=M         // get return value
@ARG
A=M
M=D         // RAM[ARG] = return value
@ARG
D=M
@SP
M=D+1
@R13        // FRAME
M=M-1       // FRAME-1
A=M
D=M
@THAT
M=D
@R13
M=M-1       // FRAME-2
A=M
D=M
@THIS
M=D
@R13
M=M-1       // FRAME-3
A=M 
D=M
@ARG
M=D
@R13
M=M-1       // FRAME-4
A=M
D=M
@LCL
M=D
@R14
A=M
0;JMP